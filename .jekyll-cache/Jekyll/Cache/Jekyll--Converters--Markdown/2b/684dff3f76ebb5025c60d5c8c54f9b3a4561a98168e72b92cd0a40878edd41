I"	<h2 id="什么是指针">什么是指针</h2>

<p>指针是一种数据结构，它指向的是数据的地址。</p>

<h2 id="指针类型">指针类型</h2>

<p>不管指针的数据类型是什么，它指向的都是地址。</p>

<h3 id="voidchar-shortint">void<em>，char</em> ，short<em>，int</em>，</h3>

<h3 id="指针和函数">指针和函数</h3>

<p>函数名保存了函数的首地址，所以函数可以用指针来寻址。</p>

<h4 id="函数指针">函数指针</h4>

<h4 id="指针函数">指针函数</h4>

<h3 id="指针和数组">指针和数组</h3>

<p>数组名保存的是数组的首地址，而且数组的元素在内存中是从低到高排列的，所以数组可以用指针来寻址。</p>

<h2 id="指针的符号运算">指针的符号运算</h2>

<h3 id="引用">引用</h3>

<p>&amp; 取地址</p>

<ul>
  <li>间接引用，取出地址中的值</li>
</ul>

<p>为什么我不直接说取值呢？
因为内存中存放的不一定是数据，也有可能是地址。</p>

<h3 id="加法和减法">加法和减法</h3>

<p>指针相减，含义是两个地址的相减。
在数组中，可以用来算出元素相差的个数</p>

<p>指针的加法，含义又是什么呢？</p>

<p>可以看一下如下代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%p %p %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"0x%x 0x%x 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="o">***</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
           <span class="c1">//    a[1][2][5]  =&amp;hello;</span>
<span class="c1">//*(*(*(a+1)+2)+5)=(int)hello;</span>

		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行结果如下：</p>

<p><img src="/images/points.png" alt="" /></p>

<p>打开OD，我们来分析一下这个代码。</p>

<p>首先，我们定义了一个96(2<em>3</em>4*sizeof(int))个字节大小的数组。</p>

<p>汇编代码如下:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0040D75E  |.  C745 A0 00000&gt;mov     dword ptr ss:[ebp-60], 0   //首地址赋值为0
0040D765  |.  B9 17000000   mov     ecx, 17 //取剩下的23个数，注意是16进制
0040D76A  |.  33C0          xor     eax, eax
0040D76C  |.  8D7D A4       lea     edi, dword ptr ss:[ebp-5C] 
0040D76F  |.  F3:AB         rep     stos dword ptr es:[edi] //剩下23个数赋值为0
</code></pre></div></div>

<p>查看堆栈</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0012FF20   00000000
0012FF24   00000000
0012FF28   00000000
0012FF2C   00000000
0012FF30   00000000
0012FF34   00000000
0012FF38   00000000
0012FF3C   00000000
0012FF40   00000000
0012FF44   00000000
0012FF48   00000000
0012FF4C   00000000
0012FF50   00000000
0012FF54   00000000
0012FF58   00000000
0012FF5C   00000000
0012FF60   00000000
0012FF64   00000000
0012FF68   00000000
0012FF6C   00000000
0012FF70   00000000
0012FF74   00000000
0012FF78   00000000
0012FF7C   00000000
0012FF80  /0012FFC0
0012FF84  |00401259  返回到 ponints.00401259 来自 ponints.00401005
</code></pre></div></div>

<p>其中 0012FF20 ~ 0012FF7c 里面存放的是数组的元素，24个从低到高排列</p>

<p>0012FF80 里面是放的是上个函数也就是main函数的ebp</p>

<p>0012FF84 里面放的是返回地址</p>

<p>然后来解释一下后面printf中表达式的值。</p>

<p>指针是有大小的。</p>

<p>指针和常量相加时，应该保证数据宽度是一样的。</p>

<p>使用 %p 来打印地址。</p>

<p>在三维数组中，a+1 等价于 <script type="math/tex">a +1 x 3 x 4 x sizeof(int)</script></p>

<p>在二维数组中，*a+1 等价于<script type="math/tex">a + 4 x sizeof(int)</script></p>

<p>在一维数组中，**a+1 等价于<script type="math/tex">a + 1 * sizeof(int)</script></p>

<p>根据上面可以得出规律，n指针的大小为后面n-1位相乘。</p>

<p>同理，上面的式子就可以很好的理解了。感兴趣的可以自己算一下。</p>

<h2 id="指针和引用">指针和引用</h2>

<p>c++ 中，推荐使用引用来代替指针。</p>

<p>从本质上来说，引用和指针没有任何区别。</p>

<p>从语法上来讲,可以把引用看成阉割版的指针。</p>

<p>为什么这么说呢？</p>

:ET