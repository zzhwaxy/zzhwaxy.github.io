I".<h2 id="什么是指针">什么是指针</h2>

<p>指针是一种数据结构，它指向的是数据的地址。</p>

<h2 id="指针类型">指针类型</h2>

<p>不管指针的数据类型是什么，它指向的都是地址。</p>

<h3 id="voidchar-shortint">void<em>，char</em> ，short<em>，int</em>，</h3>

<h3 id="指针和函数">指针和函数</h3>

<p>因为函数名保存了函数的首地址，而函数里的元素在内存中又是连续存放的，所以函数可以用指针来寻址。</p>

<h4 id="函数指针">函数指针</h4>

<h4 id="指针函数">指针函数</h4>

<h3 id="指针和数组">指针和数组</h3>

<h2 id="指针的符号运算">指针的符号运算</h2>

<h3 id="引用">引用</h3>

<p>&amp; 取地址</p>

<ul>
  <li>间接引用，取出地址中的值</li>
</ul>

<p>为什么我不直接说取值呢？
因为内存中存放的不一定是数据，也有可能是地址。</p>

<h3 id="加法和减法">加法和减法</h3>

<p>指针相减，含义是两个地址的相减。
在数组中，可以用来算出元素相差的个数</p>

<p>指针的加法，含义又是什么呢？</p>

<p>可以看一下如下代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%p %p %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"0x%x 0x%x 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="o">***</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
           <span class="c1">//    a[1][2][5]  =&amp;hello;</span>
<span class="c1">//*(*(*(a+1)+2)+5)=(int)hello;</span>

		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>打开OD，我们来分析一下这个代码。</p>

<p>首先，我们定义了一个96(2<em>3</em>4*sizeof(int))个字节大小的数组。</p>

<p>汇编代码如下:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0040D75E  |.  C745 A0 00000&gt;mov     dword ptr ss:[ebp-60], 0   //首地址赋值为0
0040D765  |.  B9 17000000   mov     ecx, 17 //取剩下的23个数，注意是16进制
0040D76A  |.  33C0          xor     eax, eax
0040D76C  |.  8D7D A4       lea     edi, dword ptr ss:[ebp-5C] 
0040D76F  |.  F3:AB         rep     stos dword ptr es:[edi] //剩下23个数赋值为0
</code></pre></div></div>

<p>###</p>

<h2 id="指针和引用">指针和引用</h2>

<p>c++ 中，推荐使用引用来代替指针。</p>

<p>从本质上来说，引用和指针没有任何区别。</p>

<p>从语法上来讲,可以把引用看成阉割版的指针。</p>

<p>为什么这么说呢？</p>

:ET